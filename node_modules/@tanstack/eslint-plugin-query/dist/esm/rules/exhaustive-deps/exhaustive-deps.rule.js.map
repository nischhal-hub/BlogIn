{"version":3,"file":"exhaustive-deps.rule.js","sources":["../../../../src/rules/exhaustive-deps/exhaustive-deps.rule.ts"],"sourcesContent":["import { AST_NODE_TYPES, ESLintUtils } from '@typescript-eslint/utils'\nimport { ASTUtils } from '../../utils/ast-utils'\nimport { getDocsUrl } from '../../utils/get-docs-url'\nimport { uniqueBy } from '../../utils/unique-by'\nimport { detectTanstackQueryImports } from '../../utils/detect-react-query-imports'\nimport { ExhaustiveDepsUtils } from './exhaustive-deps.utils'\nimport type { TSESLint } from '@typescript-eslint/utils'\n\nconst QUERY_KEY = 'queryKey'\nconst QUERY_FN = 'queryFn'\n\nexport const name = 'exhaustive-deps'\n\nconst createRule = ESLintUtils.RuleCreator(getDocsUrl)\n\nexport const rule = createRule({\n  name,\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Exhaustive deps rule for useQuery',\n      recommended: 'error' as any,\n    },\n    messages: {\n      missingDeps: `The following dependencies are missing in your queryKey: {{deps}}`,\n      fixTo: 'Fix to {{result}}',\n    },\n    hasSuggestions: true,\n    fixable: 'code',\n    schema: [],\n  },\n  defaultOptions: [],\n\n  create: detectTanstackQueryImports((context) => {\n    return {\n      Property: (node) => {\n        if (\n          !ASTUtils.isObjectExpression(node.parent) ||\n          !ASTUtils.isIdentifierWithName(node.key, QUERY_KEY)\n        ) {\n          return\n        }\n\n        const scopeManager = context.sourceCode.scopeManager\n        const queryKey = ASTUtils.findPropertyWithIdentifierKey(\n          node.parent.properties,\n          QUERY_KEY,\n        )\n        const queryFn = ASTUtils.findPropertyWithIdentifierKey(\n          node.parent.properties,\n          QUERY_FN,\n        )\n\n        if (\n          scopeManager === null ||\n          queryKey === undefined ||\n          queryFn === undefined ||\n          !ASTUtils.isNodeOfOneOf(queryFn.value, [\n            AST_NODE_TYPES.ArrowFunctionExpression,\n            AST_NODE_TYPES.FunctionExpression,\n          ])\n        ) {\n          return\n        }\n\n        let queryKeyNode = queryKey.value\n\n        if (\n          queryKeyNode.type === AST_NODE_TYPES.TSAsExpression &&\n          queryKeyNode.expression.type === AST_NODE_TYPES.ArrayExpression\n        ) {\n          queryKeyNode = queryKeyNode.expression\n        }\n\n        if (queryKeyNode.type === AST_NODE_TYPES.Identifier) {\n          const expression = ASTUtils.getReferencedExpressionByIdentifier({\n            context,\n            node: queryKeyNode,\n          })\n\n          if (expression?.type === AST_NODE_TYPES.ArrayExpression) {\n            queryKeyNode = expression\n          }\n        }\n\n        const queryKeyValue = queryKeyNode\n        const externalRefs = ASTUtils.getExternalRefs({\n          scopeManager,\n          sourceCode: context.sourceCode,\n          node: queryFn.value,\n        })\n\n        const relevantRefs = externalRefs.filter((reference) =>\n          ExhaustiveDepsUtils.isRelevantReference({\n            context,\n            reference,\n            scopeManager,\n          }),\n        )\n\n        const existingKeys = ASTUtils.getNestedIdentifiers(queryKeyValue).map(\n          (identifier) =>\n            ASTUtils.mapKeyNodeToText(identifier, context.sourceCode),\n        )\n\n        const missingRefs = relevantRefs\n          .map((ref) => ({\n            ref: ref,\n            text: ASTUtils.mapKeyNodeToText(ref.identifier, context.sourceCode),\n          }))\n          .filter(({ ref, text }) => {\n            return (\n              !ref.isTypeReference &&\n              !ASTUtils.isAncestorIsCallee(ref.identifier) &&\n              !existingKeys.some((existingKey) => existingKey === text) &&\n              !existingKeys.includes(text.split('.')[0] ?? '')\n            )\n          })\n          .map(({ ref, text }) => ({\n            identifier: ref.identifier,\n            text: text,\n          }))\n\n        const uniqueMissingRefs = uniqueBy(missingRefs, (x) => x.text)\n\n        if (uniqueMissingRefs.length > 0) {\n          const missingAsText = uniqueMissingRefs\n            .map((ref) =>\n              ASTUtils.mapKeyNodeToText(ref.identifier, context.sourceCode),\n            )\n            .join(', ')\n\n          const existingWithMissing = context.sourceCode\n            .getText(queryKeyValue)\n            .replace(/\\]$/, `, ${missingAsText}]`)\n\n          const suggestions: TSESLint.ReportSuggestionArray<string> = []\n\n          if (queryKeyNode.type === AST_NODE_TYPES.ArrayExpression) {\n            suggestions.push({\n              messageId: 'fixTo',\n              data: { result: existingWithMissing },\n              fix(fixer) {\n                return fixer.replaceText(queryKeyValue, existingWithMissing)\n              },\n            })\n          }\n\n          context.report({\n            node: node,\n            messageId: 'missingDeps',\n            data: {\n              deps: uniqueMissingRefs.map((ref) => ref.text).join(', '),\n            },\n            suggest: suggestions,\n          })\n        }\n      },\n    }\n  }),\n})\n"],"names":[],"mappings":"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"}